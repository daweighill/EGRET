---
title: "Final EGRET v1 validation: GM12878"
author: "Deborah Weighill"
date: "June 30, 2020"
output:
  html_notebook:
    toc: true
    theme: cosmo
    df_print: paged
---


# Overview
This script validates the PANDA and EGRET networks against ChIP-seq data.


# Libraries, tags and inputs
Load libraries, set tag

```{r}
library(rtracklayer)
library(tidyr)
library(pROC)
library(reshape)
library(PRROC)
library(dplyr)
library(precrec)
library(ggplot2)
tag <- "finalEgret_v1_GM12878_mouse_smart2_06302020"
chipseq <- "../../ca_egret/ca_egret_v3.1_LOO/validation/GM12878_remap2018_all_macs2_hg19_v1_2.bed"
```

# Make Panda/EGRET edge table

Load all of the PANDA/EGRET regnets

```{r echo=FALSE,results='hide'}
library(reshape2)

load("../outputs/finalEgret_v1_na12878_eQTLs_06182020_panda.RData")
net <- melt(regnet)
colnames(net) = c("tf","gene","score")
net$id <- paste0(net$tf,net$gene)

regnet_edge_table <- data.frame(net$id)
colnames(regnet_edge_table) <- c("id")
regnet_edge_table$tf <- as.vector(net$tf)
regnet_edge_table$gene <- as.vector(net$gene)
regnet_edge_table$panda <- as.vector(net$score)

#list of the file names of the rest of the networks
files <- c("finalEgret_v1_na12878_mouse_smart2_06302020_egret.RData")

#nicknames of the networks
names <- c("egret_GM12878")



for (p in c(1:1)) {
  filename <- paste0("../outputs/",files[p])
  netname <- names[p]
  print(netname)
  load(filename)
  net <- melt(regnet)
  colnames(net) = c("tf","gene","score")
  net$id <- paste0(net$tf,net$gene)
  if(all.equal(as.vector(regnet_edge_table$id),as.vector(net$id))){
    print(p)
    regnet_edge_table$tempID <- as.vector(net$score)
    #print(colnames(regnet_edge_table))
    colnames(regnet_edge_table)[colnames(regnet_edge_table) == "tempID"] <- netname
  }
}
filename <- paste0("../outputs/edge_table_",tag,".RData")
save(regnet_edge_table, file = filename)
load("../outputs/validation_table_finalEgret_v1_GM12878_mouse_smart2_06302020.RData")
```

# Load ChIP-seq data
We load the chipseq data and make a ground truth regulatory network for validation.

```{r echo=FALSE,results='hide'}
# read in the gene annotation file with gene ranges.
genes <- read.table("../annotation/ensembl_genes_from_ucsc.txt", header = TRUE,sep = "\t")
genes$promotorLeft <- ifelse(genes$strand == "+", (genes$txStart + 1 - 750), (genes$txEnd-250))
genes$promotorRight <- ifelse(genes$strand == "+", (genes$txStart + 1 + 250), (genes$txEnd+750))
gr_genes_promotor <- GRanges(seqnames = genes$chrom, ranges = IRanges(start = genes$promotorLeft, end = genes$promotorRight), strand = NULL, mcols = genes[,13:15])

# chipseq chipseq data
gr_chipseq <- import(chipseq)
overlaps <- data.frame(findOverlaps(gr_chipseq, gr_genes_promotor))
overlaps$tf_name <- gr_chipseq$name[overlaps$queryHits]
overlaps$gene_name <- gr_genes_promotor$mcols.name2[overlaps$subjectHits]
validation_regnet <- separate(overlaps, tf_name, c("exp", "tf", "cell line"), "\\.")
chipseq_regnet <- distinct(validation_regnet[,c("tf","gene_name")])
chipseq_regnet$id <- paste0(chipseq_regnet$tf,chipseq_regnet$gene)
```

# Overlap networks with ChIP-seq data
We now filter down the panda/egret networks to only include those TFs which are in the ChIP-seq data (our validation set).
```{r echo=FALSE,results='hide'}
filtered_net_table <- regnet_edge_table[(regnet_edge_table$tf %in% chipseq_regnet$tf) ,]
filtered_net_table$chipseq <- ifelse(filtered_net_table$id %in% chipseq_regnet$id,1,0)
```

# Validate entire networks

Plot ROC/PR curves for each PANDA and EGRET nework, as well as table of AUCs and PRs
```{r}
library(pROC)
library(precrec)
library(ggplot2)
# genotype validation
for (i in c(4:5)){
  specs <- colnames(filtered_net_table)[i]
  curve <- evalmod(scores = filtered_net_table[,i], labels = as.factor(filtered_net_table$chipseq),modnames = c(specs))
  autoplot(curve)
  aucs <- auc(curve)
  print(aucs)
}
```



# Validate highest difference edges with chipseq
## GM12878
```{r echo=FALSE,results='hide'}
#calculate differences
#nicknames of the networks

filtered_net_table$diff_egret <- abs(filtered_net_table$egret_GM12878 - filtered_net_table$panda)

validation_table <- filtered_net_table
filename <- paste0("../outputs/validation_table_",tag,".RData")
save(validation_table, file = filename)
load("../outputs/validation_table_finalEgret_v1_GM12878_mouse_smart2_06302020.RData")
```

```{r,results='hide',fig.show=TRUE}
names <- c("egret_GM12878")
diff_cols <- c(7)
egret_net_nums <- c(5)
panda_net_nums <- c(4)
chipseq_col <- 6
get_roc_for_diff_thresh <- function(egretNum, thresh) {
  diffcolnum <- diff_cols[egretNum]
  egretcol <- egret_net_nums[egretNum]
  panda_col <- panda_net_nums[egretNum]    
   
  
  
  top_diff_table <- validation_table[(validation_table[,c(diffcolnum)]>thresh),c(panda_col,egretcol,chipseq_col)]
  scores <- join_scores(top_diff_table[,1],top_diff_table[,2])
  labels <- join_labels(top_diff_table[,3],top_diff_table[,3])
  specs <- paste0(names[egretNum],", thresh: ",thresh)
  
  rocP <- roc(top_diff_table$chipseq, top_diff_table[,1], auc = TRUE, direction = "<")
  rocE <- roc(top_diff_table$chipseq, top_diff_table[,2],auc = TRUE, direction = "<")
  test <- roc.test(rocP, rocE, alternative = "less", method = "delong" )
  pandaAUC <- test$estimate["AUC of roc1"]
  egretAUC <- test$estimate["AUC of roc2"]
  pval <- test$p.value
  print(paste(egretNum,thresh,pval))
  
  curve_data <- mmdata(scores, labels,modnames = c("panda", specs), dsids = c(1, 2))
  curves <- evalmod(curve_data)
  nn <- attr(curves$rocs,"data_info")$nn[1]
  np <- attr(curves$rocs,"data_info")$np[1]
  result <- c(egretNum, names[egretNum], thresh, nn, np, pandaAUC, egretAUC, pval)
  return(result)
  autoplot(curves)
}

egret_priors <- c(1)
thresholds <- c(0.1, 0.15, 0.2, 0.25,0.3,0.4, 0.5, 0.75,1,1.5,2,2.5,3,4)

egret_auc_pvals<- data.frame()

for (p in egret_priors){
  for (t in thresholds){
    result <- get_roc_for_diff_thresh(p,t)
    df <- data.frame(t(result), stringsAsFactors = FALSE)
    egret_auc_pvals <- rbind(egret_auc_pvals,df)
  }
}

filename <- paste0("../outputs/AUC_pvals_",tag,".txt")
colnames(egret_auc_pvals) <- c("egretNum", "name", "thresh", "nn", "np", "pandaAUC", "egretAUC", "pval")
write.table(egret_auc_pvals, file = filename, sep = "\t", col.names = TRUE, quote=FALSE)
egret_auc_pvals
```




```{r,results='hide',fig.show=TRUE}
names <- c("egret_GM12878")
diff_cols <- c(7)
egret_net_nums <- c(5)
panda_net_nums <- c(4)
chipseq_col <- 6
get_roc_for_top_x <- function(egretNum, x) {
  egretcol <- egret_net_nums[egretNum]
  panda_col <- panda_net_nums[egretNum]
  
  top_x_table <- top_n(validation_table,x,diff_egret)[,c(panda_col,egretcol,chipseq_col)] 
  scores <- join_scores(top_x_table[,1],top_x_table[,2])
  labels <- join_labels(top_x_table[,3],top_x_table[,3])
  specs <- paste0(names[egretNum],", top ",x)
  
  rocP <- roc(top_x_table$chipseq, top_x_table[,1], auc = TRUE, direction = "<")
  rocE <- roc(top_x_table$chipseq, top_x_table[,2],auc = TRUE, direction = "<")
  test <- roc.test(rocP, rocE, alternative = "less", method = "delong" )
  pandaAUC <- test$estimate["AUC of roc1"]
  egretAUC <- test$estimate["AUC of roc2"]
  pval <- test$p.value
  print(paste(egretNum,x,pval))
  
  curve_data <- mmdata(scores, labels,modnames = c("panda", specs), dsids = c(1, 2))
  curves <- evalmod(curve_data)
  nn <- attr(curves$rocs,"data_info")$nn[1]
  np <- attr(curves$rocs,"data_info")$np[1]
  result <- c(egretNum, names[egretNum], x, nn, np, pandaAUC, egretAUC, pval)
  return(result)
  autoplot(curves)
}

egret_priors <- c(1)
#numEdges <- c(10,20,30,40,50,60,100)
numEdges <- c(110,120,130,140,150,160,200)
egret_auc_pvals_topn<- data.frame()

for (p in egret_priors){
  for (x in numEdges){
    result <- get_roc_for_top_x(p,x)
    df <- data.frame(t(result), stringsAsFactors = FALSE)
    egret_auc_pvals_topn <- rbind(egret_auc_pvals_topn,df)
  }
}

filename <- paste0("../outputs/AUC_pvals_topN_",tag,".txt")
colnames(egret_auc_pvals_topn) <- c("egretNum", "name", "topN", "nn", "np", "pandaAUC", "egretAUC", "pval")
write.table(egret_auc_pvals_topn, file = filename, sep = "\t", col.names = TRUE, quote=FALSE)
egret_auc_pvals_topn
```



```{r, fig.show=TRUE, echo=FALSE,results='hide'}
names <- c("egret_GM12878")
diff_cols <- c(7)
egret_net_nums <- c(5)
panda_net_nums <- c(4)
chipseq_col <- 6

get_roc_for_diff_thresh <- function(egretNum, thresh) {
  diffcolnum <- diff_cols[egretNum]
  egretcol <- egret_net_nums[egretNum]
  panda_col <- panda_net_nums[egretNum]
  
  top_diff_table <- validation_table[(validation_table[,c(diffcolnum)]>thresh),c(panda_col,egretcol,chipseq_col)]
  scores <- join_scores(top_diff_table[,1],top_diff_table[,2])
  labels <- join_labels(top_diff_table[,3],top_diff_table[,3])
  specs <- paste0(names[egretNum],", thresh: ",thresh)
  curve_data <- mmdata(scores, labels,modnames = c("panda", specs), dsids = c(1, 2))
  curves <- evalmod(curve_data)
  aucs <- auc(curves)
  print(aucs)
  autoplot(curves)
}


egret_priors <- c(1)
#thresholds <- c(0.5)
thresholds <- c(0.05,0.1,0.25,0.3,0.4,0.5,0.75,1,2,3)


for (p in egret_priors){
  for (t in thresholds){
    get_roc_for_diff_thresh(p,t)
  }
}
```

# Make a table of the "top difference" edges
We want to make a table of the top difference edges to make sure there are not any "biases". We will include all the eQTLs that are contributing.

Load the eQTL, qbic, motif data from when we ran EGRET to select out the eQTLs which constributed to the prior.
```{r}
qbic <- read.table(file = "../inputs/qbic_eQTLS_GM12878_K562_finalEGRET_v1_06182020.txt", header = FALSE)
vcf <- read.table("../genotype_data/NA12878.vcf", header = FALSE, sep = "\t")
motif <- load("../inputs/panda_motif_prior_finalEGRET_v1.RData")
qtl <- read.table("../inputs/eQTL_in_motif_promotor_adjacent_egene_finalEGRET_v1_06172020.txt", header = FALSE)
colnames(qtl) <- c("tf",	"gene", "snpPos",	"chr",	"effect")
qtl$snpID <- paste0(qtl$chr,"_",qtl$snpPos)
colnames(qbic) <- c("snpID",	"tf",	"gene",	"qbicEffectSize","qbicEffect")

# aggregate the qbic data per SNP -> function to return the maximum effect size of a qbic SNP 
maxabs <- function(x){
  location <- which(abs(x) == max(abs(x)))
  return(x[location])
}
qbic_uniq <- distinct(qbic)
qbic_uniq$catid <- paste0(qbic_uniq$snpID,qbic_uniq$tf,qbic_uniq$gene,qbic_uniq$qbicEffectSize)
qbic_ag <- aggregate(qbic_uniq$qbicEffectSize, by = list(qbic_uniq$snpID,qbic_uniq$tf,qbic_uniq$gene), FUN = maxabs)
colnames(qbic_ag) <- c("snpID","tf","gene","qbicEffectSize")
qbic_ag$catid <- paste0(qbic_ag$snpID,qbic_ag$tf,qbic_ag$gene,qbic_ag$qbicEffectSize)
qbic_ag$qbicEffect <- qbic_uniq$qbicEffect[match(qbic_ag$catid,qbic_uniq$catid)]
#absQbicEffectSize - absolute value of the qbic effect (which is negative)
qbic_ag$absQbicEffectSize <- abs(qbic_ag$qbicEffectSize)
colnames(vcf) <- c("CHROM",  "POS"  ,   "ID"  ,    "REF"  ,   "ALT"   ,  "QUAL"   , "FILTER" , "INFO"   , "FORMAT", "NA12878")
snp_ids <- paste0(vcf$CHROM,"_",vcf$POS)
rownames(vcf) <- snp_ids
vcf <- separate(vcf, NA12878, c("allele1", "allele2"), "\\|", remove = TRUE)
vcf$alt_allele_count <- as.numeric(vcf$allele1) + as.numeric(vcf$allele2)
vcf$snp_id <- snp_ids
#assign alt allele count of the individual to the qbic table
qbic_ag$alt_allele_count <- vcf$alt_allele_count[match(qbic_ag$snpID, vcf$snp_id)]
#assign alt allele count of the individual to the QTL table
qtl$alt_allele_count <- vcf$alt_allele_count[match(qtl$snpID, vcf$snp_id)]
QTL_tf_gene_pairs <- distinct(qtl[,c(1:7)])
QTL_tf_gene_pairs$edgeE <- rep(1,nrow(QTL_tf_gene_pairs))
QTL_tf_gene_pairs$alt_allele_count[is.na(QTL_tf_gene_pairs$alt_allele_count)] <- 0
QTL_tf_gene_pairs$qtlTF <- paste0(QTL_tf_gene_pairs$tf,QTL_tf_gene_pairs$snpID)
qbic_ag$snpTF <- paste0(qbic_ag$tf,qbic_ag$snpID)
QTL_tf_gene_pairs$qbicEffectSize <- qbic_ag$qbicEffectSize[match(QTL_tf_gene_pairs$qtlTF, qbic_ag$snpTF)]
QTL_tf_gene_pairs$qbicEffect <- qbic_ag$qbicEffect[match(QTL_tf_gene_pairs$qtlTF, qbic_ag$snpTF)]
QTL_tf_gene_pairs$absQbicEffectSize <- qbic_ag$absQbicEffectSize[match(QTL_tf_gene_pairs$qtlTF, qbic_ag$snpTF)]
QTL_tf_gene_pairs[is.na(QTL_tf_gene_pairs)] <- 0
binding_qtls <- QTL_tf_gene_pairs[which(QTL_tf_gene_pairs$qbicEffect != 0),c(1,2,4,3,5,7,9)]
binding_qtls$id <- paste0(binding_qtls$tf,binding_qtls$gene)
```

Load network table and select "high diff" edges (in full network and validation set)

```{r}
load("../outputs/edge_table_finalEgret_v1_GM12878_06182020.RData")
load("../outputs/validation_table_finalEgret_v1_GM12878_06182020.RData")
regnet_edge_table$diff <- abs(regnet_edge_table$panda-regnet_edge_table$egret_GM12878)
top_diff_whole_net <- regnet_edge_table[which(regnet_edge_table$diff > 0.5),]
top_diff_validation_subset <- validation_table[which(validation_table$diff_egret > 0.5),]
```

```{r}
dim(top_diff_whole_net)
dim(top_diff_validation_subset)
```

Select the eQTLs constributing to these edges
```{r}
qtls_topdiff_edges_whole_network <- binding_qtls[which(binding_qtls$id %in% top_diff_whole_net$id),]
qtls_topdiff_edges_validation_subset <- binding_qtls[which(binding_qtls$id %in% top_diff_validation_subset$id),]
dim(qtls_topdiff_edges_whole_network)
dim(qtls_topdiff_edges_validation_subset)
```

```{r}
write.table(qtls_topdiff_edges_validation_subset, file = "../outputs/top_diff_edges_qtls_validation_subset.txt", sep = "\t", quote = FALSE, col.names = TRUE, row.names = FALSE)
write.table(qtls_topdiff_edges_whole_network, file = "../outputs/top_diff_edges_qtls_whole_network.txt", sep = "\t", quote = FALSE, col.names = TRUE, row.names = FALSE)

```

```{r}
load("../outputs/validation_table_finalEgret_v1_GM12878_06182020.RData")
validation_table$disrupt <- 1 - validation_table$chipseq

```

```{r}
validation_table_thresh <- validation_table[which(validation_table$diff_egret > 0.5),]
curve <- evalmod(scores = validation_table_thresh$diff_egret, labels = validation_table_thresh$disrupt, posclass = 1)
autoplot(curve)
aucs <- auc(curve)
aucs
```

```{r}
validation_table_thresh <- validation_table[which(validation_table$diff_egret > 0.5),]
curve <- evalmod(scores = -validation_table_thresh$panda, labels = validation_table_thresh$disrupt, posclass = 1)
autoplot(curve)
aucs <- auc(curve)
aucs
```

Do in the disrupted edges, EGRET is good at predicting the "negative class" using the difference scores.